#!/usr/bin/env python3

import argparse
import subprocess

from pathlib import Path
from operator import add
from typing import Optional
from itertools import chain
from functools import reduce
from secrets import token_hex
from datetime import datetime
from dataclasses import dataclass
from collections.abc import Iterable
from tempfile import TemporaryDirectory
from ffmpeg_normalize import FFmpegNormalize
from pydub import AudioSegment, effects, silence

CHUNK_LENGTH = 8
OUTPUT_FOLDER = Path("data/raw/seri")
SEPARATED_FOLDER = Path("separated")


@dataclass
class TimeRange:
    start_ms: int
    end_ms: int


@dataclass
class RawSourceOperation:
    source: Path
    section_name: str
    section_range: Optional[TimeRange]


@dataclass
class SeparatedSourceOperation:
    source: Path
    source_name: str
    output_folder: Path


class RawSourceOperationResolver:
    def __init__(self, path: Path, use_cue: bool):
        self.path = path.resolve(strict=True)
        self.use_cue = use_cue

    def __iter__(self) -> Iterable[RawSourceOperation]:
        yield from self.get_operations(self.path)

    def get_operations(self, path: Path) -> Iterable[RawSourceOperation]:
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.suffix != ".cue":
            if self.use_cue:
                cue_file = path.with_suffix(".cue")
                if cue_file.exists():
                    section_ranges = self.get_section_ranges(cue_file)
                    for index, section_range in enumerate(section_ranges):
                        section_name = f"{path.stem}_{index}"
                        yield RawSourceOperation(path, section_name, section_range)
            else:
                yield RawSourceOperation(path, path.stem, None)

    def get_section_ranges(self, cue_file: Path) -> Iterable[TimeRange]:
        def timestamp_to_milliseconds(timestamp):
            hours, minutes, seconds = map(int, timestamp.split(":"))
            total_seconds = hours * 3600 + minutes * 60 + seconds
            return total_seconds * 1000

        with open(cue_file) as f:
            for line in f:
                timestamps = line.strip().split("-")
                if len(timestamps) == 2:
                    start_ms, end_ms = map(timestamp_to_milliseconds, timestamps)
                    yield TimeRange(start_ms, end_ms)


class SeparatedSourceOperationResolver:
    def __init__(self, path: Path, output_folder: Path):
        self.path = path.resolve(strict=True)
        self.output_folder = output_folder

    def __iter__(self) -> Iterable[SeparatedSourceOperation]:
        yield from self.get_operations(self.path)

    def get_operations(self, path: Path):
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.name == "vocals.wav":
            yield SeparatedSourceOperation(path, path.parent.name, self.output_folder)


class WorkdirContext:
    def __init__(self):
        self._workdir = TemporaryDirectory()

    @property
    def workdir(self):
        return Path(self._workdir.name)

    def __del__(self):
        self._workdir.cleanup()


class RawSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: RawSourceOperation, use_gpu: bool):
        super().__init__()
        self.operation = operation
        self.use_gpu = use_gpu

    def __call__(self) -> Path:
        section = self.extract_section(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.section_name}.wav"),
            self.operation.section_range,
        )
        vocals = self.separate_vocals(section)

        return vocals

    def extract_section(
        self, source: Path, output: Path, section_range: Optional[TimeRange]
    ) -> Path:
        segment = AudioSegment.from_file(source)

        (
            (
                segment[section_range.start_ms : section_range.end_ms]
                if section_range is not None
                else segment
            )
            .set_channels(2)
            .set_frame_rate(44100)
            .export(output, format="wav")
        )

        return output

    def separate_vocals(self, source: Path) -> Path:
        demucs_args = ["demucs", "--two-stems=vocals", source]
        if not self.use_gpu:
            demucs_args[1:1] = ["-d", "cpu"]

        subprocess.run(demucs_args, check=True)

        output = next(SEPARATED_FOLDER.glob(f"**/{source.stem}/vocals.wav"))

        return output


class SeparatedSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: SeparatedSourceOperation):
        super().__init__()
        self.operation = operation

    def __call__(self):
        silence_removed = self.remove_silence(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.source_name}_silenceremoved.wav"),
        )
        compressed = self.compress(
            silence_removed,
            silence_removed.with_stem(f"{silence_removed.stem}_compressed"),
        )
        normalized = self.normalize(
            compressed,
            compressed.with_stem(f"{compressed.stem}_normalized"),
        )
        spliced = self.splice(normalized)

        return spliced

    def remove_silence(self, source: Path, output: Path) -> Path:
        (
            reduce(
                add,
                silence.split_on_silence(
                    AudioSegment.from_wav(source), silence_thresh=-50
                ),
                AudioSegment.empty(),
            ).export(output, format="wav")
        )

        return output

    def compress(self, source: Path, output: Path) -> Path:
        effects.compress_dynamic_range(AudioSegment.from_wav(source)).export(
            output, format="wav"
        )

        return output

    def normalize(self, source: Path, output: Path) -> Path:
        normalizer = FFmpegNormalize(
            print_stats=True,
            keep_loudness_range_target=True,
            output_format="wav",
            debug=True,
        )
        normalizer.add_media_file(str(source), str(output))
        normalizer.run_normalization()

        return output

    def splice(self, source: Path) -> list[Path]:
        chunk_length_ms = CHUNK_LENGTH * 1000
        chunks = filter(
            lambda chunk: len(chunk) == chunk_length_ms,
            AudioSegment.from_wav(source)[::chunk_length_ms],
        )

        today = datetime.now().strftime("%Y%m%d")
        batch_id = token_hex(3)

        def export(index, chunk):
            output = self.operation.output_folder.joinpath(
                f"{source.stem}_spliced_{today}_{batch_id}_{index}.wav"
            )
            chunk.export(output, format="wav")
            return output

        return [export(index, chunk) for index, chunk in enumerate(chunks)]


def run_raw(path: Path, use_cue: bool, use_gpu: bool) -> Path:
    for operation in RawSourceOperationResolver(path, use_cue):
        executor = RawSourceOperationExecutor(operation, use_gpu)
        yield executor()


def run_separated(path: Path):
    for operation in SeparatedSourceOperationResolver(path, OUTPUT_FOLDER):
        executor = SeparatedSourceOperationExecutor(operation)
        yield executor()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "path",
        nargs="?",
        type=Path,
        default=Path("vod"),
        help="file or directory to process",
    )
    parser.add_argument(
        "--gpu", action="store_true", help="use gpu in vocal separation"
    )
    parser.add_argument(
        "--no-cue",
        action="store_true",
        help="ignore cue file; processing will run on whole file",
    )
    parser.add_argument(
        "--skip-separate", action="store_true", help="skip vocal separation"
    )
    parser.add_argument(
        "--separate-only", action="store_true", help="run vocal separation only"
    )
    parser.add_argument(
        "--separate-single",
        action="store_true",
        help="separate single file; equivalent to --no-cue and --skip-separate",
    )
    args = parser.parse_args()

    if args.separate_single:
        args.no_cue = True
        args.separate_only = True

    OUTPUT_FOLDER.mkdir(parents=True, exist_ok=True)

    raw_results = None
    if args.skip_separate:
        raw_results = [SEPARATED_FOLDER]
    else:
        raw_results = run_raw(args.path, not args.no_cue, args.gpu)

    for raw_path in raw_results:
        if not args.separate_only:
            for separated_result in run_separated(raw_path):
                for separated_path in separated_result:
                    print(f"{raw_path} output: {separated_path}")

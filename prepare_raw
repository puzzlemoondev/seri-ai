#!/usr/bin/env python3

import os
import ffmpeg
import argparse
import subprocess

from math import ceil
from pathlib import Path
from typing import Optional
from secrets import token_hex
from datetime import datetime
from dataclasses import dataclass
from collections.abc import Iterable
from tempfile import TemporaryDirectory
from ffmpeg_normalize import FFmpegNormalize

CHUNK_LENGTH = 8

OUTPUT_FOLDER = Path("data/raw/seri")
SEPARATED_FOLDER = Path("separated")


@dataclass
class TimeRange:
    start: str
    end: str


@dataclass
class RawSourceOperation:
    source: Path
    section_name: str
    section_range: Optional[TimeRange]


@dataclass
class SeparatedSourceOperation:
    source: Path
    source_name: str
    output_folder: Path


class RawSourceOperationResolver:
    def __init__(self, path: Path):
        self.path = path.resolve(strict=True)

    def __iter__(self) -> Iterable[RawSourceOperation]:
        yield from self.get_operations(self.path)

    def get_operations(self, path: Path) -> Iterable[RawSourceOperation]:
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.suffix != ".cue":
            cue_file = path.with_suffix(".cue")
            if cue_file.exists():
                section_ranges = self.get_section_ranges(cue_file)
                for index, section_range in enumerate(section_ranges):
                    section_name = f"{path.stem}_{index}"
                    yield RawSourceOperation(path, section_name, section_range)

    def get_section_ranges(self, cue_file: Path) -> Iterable[TimeRange]:
        with open(cue_file) as f:
            for line in f:
                timestamps = line.strip().split("-")
                if len(timestamps) == 2:
                    yield TimeRange(timestamps[0], timestamps[1])


class SeparatedSourceOperationResolver:
    def __init__(self, path: Path, output_folder: Path):
        self.path = path.resolve(strict=True)
        self.output_folder = output_folder

    def __iter__(self) -> Iterable[SeparatedSourceOperation]:
        for source in self.get_sources(self.path):
            yield SeparatedSourceOperation(source, self.output_folder)

    def get_operations(self, path: Path):
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.name == "vocals.wav":
            yield SeparatedSourceOperation(path, path.parent.name, self.output_folder)


class WorkdirContext:
    def __init__(self):
        self._workdir = TemporaryDirectory()

    @property
    def workdir(self):
        return Path(self._workdir.name)

    def __del__(self):
        self._workdir.cleanup()


class RawSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: RawSourceOperation, use_gpu: bool):
        super().__init__()
        self.operation = operation
        self.use_gpu = use_gpu

    def __call__(self) -> Path:
        section = self.extract_section(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.section_name}.wav"),
            self.operation.section_range,
        )
        vocals = self.separate_vocals(section)

        return vocals.resolve(strict=True)

    def extract_section(
        self, source: Path, output: Path, section_range: Optional[TimeRange]
    ) -> Path:
        section_args = dict()
        if section_range is not None:
            section_args.update(ss=section_range.start, to=section_range.end)

        (
            ffmpeg.input(str(source))
            .output(str(output), ac=2, ar=44100, format="wav", **section_args)
            .run()
        )

        return output

    def separate_vocals(self, file: Path) -> Path:
        vocal_separarion_args = ["./separate_vocals", file]
        if self.use_gpu:
            vocal_separarion_args.insert(1, "--gpu")

        subprocess.run(vocal_separarion_args, check=True)

        output = next(SEPARATED_FOLDER.glob(f"**/{file.stem}/vocals.wav"))

        return output


class SeparatedSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: SeparatedSourceOperation):
        super().__init__()
        self.operation = operation

    def __call__(self):
        silence_removed = self.remove_silence(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.source_name}_normalized"),
        )
        normalized = self.normalize(
            silence_removed,
            silence_removed.with_stem(f"{silence_removed.stem}_silenceremoved"),
        )
        self.splice(normalized)

    def normalize(self, source: Path, output: Path) -> list[Path]:
        output = self.workdir.joinpath(f"{source.stem}_normalized")

        normalizer = FFmpegNormalize(output_format="wav", debug=True)
        normalizer.add_media_file(str(source), str(output))
        normalizer.run_normalization()

        return output

    def remove_silence(self, source: Path, output: Path) -> Path:
        output = source.with_stem(f"{source.stem}_silenceremoved")

        (
            ffmpeg.input(str(source))
            .filter(
                "silenceremove",
                stop_periods=-1,
                stop_duration=1,
                stop_threshold="-50dB",
            )
            .output(str(output))
            .run()
        )

        return output

    def splice(self, source: Path):
        now = datetime.now().strftime("%Y%m%d")
        batch_id = token_hex(3)
        output = self.operation.output_folder.joinpath(
            f"{source.stem}_spliced_{now}_{batch_id}_%06d.wav"
        )

        (
            ffmpeg.input(str(source))
            .output(str(output), f="segment", segment_time=CHUNK_LENGTH)
            .run()
        )

        last_chunk = max(self.operation.output_folder.glob(f"*{batch_id}*.wav"))
        last_chunk.unlink()  # remove last incomplete chunk


def run_raw(path: Path, use_gpu: bool) -> Path:
    for operation in RawSourceOperationResolver(path):
        executor = RawSourceOperationExecutor(operation, use_gpu)
        yield executor()


def run_separated(path: Path):
    for operation in SeparatedSourceOperationResolver(source, OUTPUT_FOLDER):
        executor = SeparatedSourceOperationExecutor(operation)
        yield executor()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("path", nargs="?", type=Path, default=Path("vod"))
    parser.add_argument("--separated", action="store_true")
    parser.add_argument("--gpu", action="store_true")
    args = parser.parse_args()

    OUTPUT_FOLDER.mkdir(parents=True, exist_ok=True)

    raw_results = (
        list(run_raw(args.path, args.gpu)) if not args.separated else [SEPARATED_FOLDER]
    )

    separated_results = [run_separated(path) for path in raw_results]

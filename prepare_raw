#!/usr/bin/env python3

import argparse
import subprocess

from pathlib import Path
from operator import add
from itertools import chain
from functools import reduce
from secrets import token_hex
from datetime import datetime
from pydub import AudioSegment, silence
from dataclasses import dataclass
from collections.abc import Iterable
from tempfile import TemporaryDirectory
from ffmpeg_normalize import FFmpegNormalize

CHUNK_LENGTH = 8
OUTPUT_FOLDER = Path("data/raw/seri")
SEPARATED_FOLDER = Path("separated")


@dataclass
class TimeRange:
    start_ms: int
    end_ms: int


@dataclass
class RawSourceOperation:
    source: Path
    section_name: str
    section_range: TimeRange


@dataclass
class SeparatedSourceOperation:
    source: Path
    source_name: str
    output_folder: Path


class RawSourceOperationResolver:
    def __init__(self, path: Path):
        self.path = path.resolve(strict=True)

    def __iter__(self) -> Iterable[RawSourceOperation]:
        yield from self.get_operations(self.path)

    def get_operations(self, path: Path) -> Iterable[RawSourceOperation]:
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.suffix != ".cue":
            cue_file = path.with_suffix(".cue")
            if cue_file.exists():
                section_ranges = self.get_section_ranges(cue_file)
                for index, section_range in enumerate(section_ranges):
                    section_name = f"{path.stem}_{index}"
                    yield RawSourceOperation(path, section_name, section_range)

    def get_section_ranges(self, cue_file: Path) -> Iterable[TimeRange]:
        def timestamp_to_milliseconds(timestamp):
            hours, minutes, seconds = map(int, timestamp.split(":"))
            total_seconds = hours * 3600 + minutes * 60 + seconds
            return total_seconds * 1000

        with open(cue_file) as f:
            for line in f:
                timestamps = line.strip().split("-")
                if len(timestamps) == 2:
                    start_ms, end_ms = map(timestamp_to_milliseconds, timestamps)
                    yield TimeRange(start_ms, end_ms)


class SeparatedSourceOperationResolver:
    def __init__(self, path: Path, output_folder: Path):
        self.path = path.resolve(strict=True)
        self.output_folder = output_folder

    def __iter__(self) -> Iterable[SeparatedSourceOperation]:
        yield from self.get_operations(self.path)

    def get_operations(self, path: Path):
        if path.is_dir():
            for child in path.iterdir():
                yield from self.get_operations(child)
        elif path.name == "vocals.wav":
            yield SeparatedSourceOperation(path, path.parent.name, self.output_folder)


class WorkdirContext:
    def __init__(self):
        self._workdir = TemporaryDirectory()

    @property
    def workdir(self):
        return Path(self._workdir.name)

    def __del__(self):
        self._workdir.cleanup()


class RawSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: RawSourceOperation, use_gpu: bool):
        super().__init__()
        self.operation = operation
        self.use_gpu = use_gpu

    def __call__(self) -> Path:
        section = self.extract_section(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.section_name}.wav"),
            self.operation.section_range,
        )
        vocals = self.separate_vocals(section)

        return vocals

    def extract_section(
        self, source: Path, output: Path, section_range: TimeRange
    ) -> Path:
        (
            AudioSegment.from_file(source)[
                section_range.start_ms : section_range.end_ms
            ]
            .set_channels(2)
            .set_frame_rate(44100)
            .export(output, format="wav")
        )

        return output

    def separate_vocals(self, source: Path) -> Path:
        subprocess.run(["./separate_vocals", source], check=True)

        output = next(SEPARATED_FOLDER.glob(f"**/{source.stem}/vocals.wav"))

        return output


class SeparatedSourceOperationExecutor(WorkdirContext):
    def __init__(self, operation: SeparatedSourceOperation):
        super().__init__()
        self.operation = operation

    def __call__(self):
        silence_removed = self.remove_silence(
            self.operation.source,
            self.workdir.joinpath(f"{self.operation.source_name}_silenceremoved.wav"),
        )
        normalized = self.normalize(
            silence_removed,
            silence_removed.with_stem(f"{silence_removed.stem}_normalized"),
        )
        spliced = self.splice(normalized)

        return spliced

    def remove_silence(self, source: Path, output: Path) -> Path:
        (
            reduce(
                add,
                silence.split_on_silence(
                    AudioSegment.from_wav(source), silence_thresh=-50
                ),
                AudioSegment.empty(),
            ).export(output, format="wav")
        )

        return output

    def normalize(self, source: Path, output: Path) -> Path:
        normalizer = FFmpegNormalize(
            print_stats=True,
            keep_loudness_range_target=True,
            output_format="wav",
            debug=True,
        )
        normalizer.add_media_file(str(source), str(output))
        normalizer.run_normalization()

        return output

    def splice(self, source: Path) -> list[Path]:
        chunk_length_ms = CHUNK_LENGTH * 1000
        chunks = filter(
            lambda chunk: len(chunk) == chunk_length_ms,
            AudioSegment.from_wav(source)[::chunk_length_ms],
        )

        today = datetime.now().strftime("%Y%m%d")
        batch_id = token_hex(3)

        def export(index, chunk):
            output = self.operation.output_folder.joinpath(
                f"{source.stem}_spliced_{today}_{batch_id}_{index}.wav"
            )
            chunk.export(output, format="wav")
            return output

        return [export(index, chunk) for index, chunk in enumerate(chunks)]


def run_raw(path: Path, use_gpu: bool) -> Path:
    for operation in RawSourceOperationResolver(path):
        executor = RawSourceOperationExecutor(operation, use_gpu)
        yield executor()


def run_separated(path: Path):
    for operation in SeparatedSourceOperationResolver(path, OUTPUT_FOLDER):
        executor = SeparatedSourceOperationExecutor(operation)
        yield executor()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("path", nargs="?", type=Path, default=Path("vod"))
    parser.add_argument("--separated", action="store_true")
    parser.add_argument("--gpu", action="store_true")
    args = parser.parse_args()

    OUTPUT_FOLDER.mkdir(parents=True, exist_ok=True)

    raw_results = None
    if args.separated:
        raw_results = [SEPARATED_FOLDER]
    else:
        raw_results = run_raw(args.path, args.gpu)

    for raw_path in raw_results:
        print(f"{args.path} output: {raw_path}")
        for separated_result in run_separated(raw_path):
            for separated_path in separated_result:
                print(f"{raw_path} output: {separated_path}")

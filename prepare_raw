#!/usr/bin/env python3

import os
import argparse
import subprocess

from math import ceil
from pathlib import Path
from typing import Optional
from dataclasses import dataclass
from collections.abc import Iterable

OUTPUT_FOLDER = Path("data/raw/seri")


@dataclass
class TimeRange:
    start: str
    end: str


@dataclass
class Operation:
    source: Path
    section_output: Path
    section_range: Optional[TimeRange]


def get_section_ranges(cue_file: Path) -> Iterable[TimeRange]:
    with open(cue_file) as f:
        for line in f:
            timestamps = line.strip().split("-")
            if len(timestamps) == 2:
                yield TimeRange(timestamps[0], timestamps[1])


def extract_section(
    source: Path, output: Path, section_range: Optional[TimeRange] = None
) -> Path:
    ffmpeg_args = [
        "ffmpeg",
        "-y",
        "-i",
        source,
        "-ac",
        "2",
        "-ar",
        "44100",
        "-f",
        "wav",
        output,
    ]

    if section_range is not None:
        ffmpeg_args[1:1] = [
            "-ss",
            section_range.start,
            "-to",
            section_range.end,
        ]

    subprocess.run(ffmpeg_args, check=True)

    return output


def separate_vocals(file: Path, use_gpu: bool) -> Path:
    vocal_separarion_args = ["./separate_vocals", file]
    if use_gpu:
        vocal_separarion_args.insert(1, "--gpu")

    subprocess.run(vocal_separarion_args, check=True)

    output = next(Path("separated").glob(f"**/{file.stem}/vocals.wav"))

    return output


def remove_silence(source: Path) -> Path:
    output = source.with_stem(f"{source.stem}_silence_removed")

    ffmpeg_args = [
        "ffmpeg",
        "-y",
        "-i",
        source,
        "-af",
        "silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-50dB",
        output,
    ]

    subprocess.run(ffmpeg_args, check=True)

    return output


def get_chunks(source: Path) -> list[int]:
    duration_output = subprocess.check_output(
        ["./get_duration", source], encoding="utf-8"
    )
    duration = ceil(float(duration_output))

    ideal_chunk_length = 10
    min_chunk_length = 5
    chunks = list(range(ideal_chunk_length, duration, ideal_chunk_length))
    if (duration - chunks[-1]) <= min_chunk_length:
        chunks.pop()

    return chunks


def splice(source: Path, chunks: list[int]):
    output_filename = source.with_stem(f"{source.parent.name}_{source.stem}_%02d").name
    output = OUTPUT_FOLDER.joinpath(output_filename)

    ffmpeg_args = [
        "ffmpeg",
        "-y",
        "-i",
        source,
        "-c",
        "copy",
        "-f",
        "segment",
        "-segment_times",
        ",".join(map(str, chunks)),
        output,
    ]

    subprocess.run(ffmpeg_args, check=True)


def get_operations(source: Path) -> Iterable[Operation]:
    if source.is_dir():
        for child in source.iterdir():
            yield from get_operations(child)
    elif source.suffix != ".cue":
        cue_file = source.with_suffix(".cue")
        if cue_file.exists():
            section_ranges = get_section_ranges(cue_file)
            for index, section_range in enumerate(section_ranges):
                output = source.with_name(f"{source.stem}_{index}.wav")
                yield Operation(source, output, section_range)


parser = argparse.ArgumentParser()
parser.add_argument("path", type=Path)
parser.add_argument("--gpu", action="store_true")
args = parser.parse_args()

OUTPUT_FOLDER.mkdir(parents=True, exist_ok=True)

for operation in get_operations(args.path):
    converted = extract_section(
        operation.source, operation.section_output, operation.section_range
    )
    vocals = separate_vocals(converted, args.gpu)
    silence_removed = remove_silence(vocals)
    chunks = get_chunks(silence_removed)
    splice(silence_removed, chunks)
